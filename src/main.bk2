import flet as ft
import flet.canvas as cv
import numpy as np

def main(page: ft.Page):
    # Set page properties
    page.title = "GeoGebra Calculator Suite"
    page.vertical_alignment = ft.MainAxisAlignment.CENTER
    page.horizontal_alignment = ft.CrossAxisAlignment.CENTER
    page.padding = 0
    page.window_width = 1200
    page.window_height = 800
    page.bgcolor = ft.Colors.WHITE
    
    # State variables for the graph
    state = {
        "scale": 50.0,
        "offset_x": 0.0,
        "offset_y": 0.0,
        "expr": "x**2"
    }
    
    # Create navigation drawer items
    drawer_items = [
        ft.Container(height=12),
        ft.NavigationDrawerDestination(
            label="Algebra",
            icon=ft.Icons.ADD_OUTLINED,
            selected_icon=ft.Icons.ADD,
        ),
        ft.NavigationDrawerDestination(
            label="Tools",
            icon=ft.Icons.SETTINGS_OUTLINED,
            selected_icon=ft.Icons.SETTINGS,
        ),
        ft.NavigationDrawerDestination(
            label="Table",
            icon=ft.Icons.TABLE_CHART_OUTLINED,
            selected_icon=ft.Icons.TABLE_CHART,
        ),
        ft.NavigationDrawerDestination(
            label="Spreadsheet",
            icon=ft.Icons.GRID_ON_OUTLINED,
            selected_icon=ft.Icons.GRID_ON,
        ),
    ]
    
    # Create navigation drawer
    def handle_drawer_dismiss(e: ft.Event[ft.NavigationDrawer]):
        print("Drawer dismissed!")
    
    async def handle_drawer_change(e: ft.Event[ft.NavigationDrawer]):
        print(f"Selected Index changed: {e.control.selected_index}")
        await page.close_drawer()
    
    navigation_drawer = ft.NavigationDrawer(
        controls=drawer_items,
        on_dismiss=handle_drawer_dismiss,
        on_change=handle_drawer_change,
    )
    
    # Canvas functions
    def to_screen(x, y, width, height):
        """Convert mathematical coordinates to screen coordinates"""
        sx = (width / 2) + state["offset_x"] + (x * state["scale"])
        sy = (height / 2) + state["offset_y"] - (y * state["scale"])
        return sx, sy
    
    def draw_graph(canvas_width, canvas_height):
        """Draw the coordinate system and graph"""
        shapes = []
        
        # Draw grid lines
        grid_step = 1.0
        if state["scale"] < 20:
            grid_step = 5.0
        if state["scale"] > 150:
            grid_step = 0.5
        
        grid_pen = ft.Paint(color=ft.Colors.GREY_300, stroke_width=1)
        minor_grid_pen = ft.Paint(color=ft.Colors.GREY_100, stroke_width=0.5)
        
        # Calculate visible range
        visible_x_min = -canvas_width / state["scale"]
        visible_x_max = canvas_width / state["scale"]
        visible_y_min = -canvas_height / state["scale"]
        visible_y_max = canvas_height / state["scale"]
        
        # Major grid lines (every 2 units)
        for x in np.arange(-20, 21, 2):
            sx, _ = to_screen(x, 0, canvas_width, canvas_height)
            if 0 <= sx <= canvas_width:
                shapes.append(cv.Line(sx, 0, sx, canvas_height, grid_pen))
        
        for y in np.arange(-20, 21, 2):
            _, sy = to_screen(0, y, canvas_width, canvas_height)
            if 0 <= sy <= canvas_height:
                shapes.append(cv.Line(0, sy, canvas_width, sy, grid_pen))
        
        # Minor grid lines (every 1 unit)
        for x in np.arange(-20, 21, 1):
            sx, _ = to_screen(x, 0, canvas_width, canvas_height)
            if 0 <= sx <= canvas_width and x % 2 != 0:
                shapes.append(cv.Line(sx, 0, sx, canvas_height, minor_grid_pen))
        
        for y in np.arange(-20, 21, 1):
            _, sy = to_screen(0, y, canvas_width, canvas_height)
            if 0 <= sy <= canvas_height and y % 2 != 0:
                shapes.append(cv.Line(0, sy, canvas_width, sy, minor_grid_pen))
        
        # Draw axes
        axis_pen = ft.Paint(color=ft.Colors.BLACK, stroke_width=2)
        cx, cy = to_screen(0, 0, canvas_width, canvas_height)
        
        # X-axis
        shapes.append(cv.Line(0, cy, canvas_width, cy, axis_pen))
        # Y-axis
        shapes.append(cv.Line(cx, 0, cx, canvas_height, axis_pen))
        
        # Draw axis arrows
        arrow_size = 10
        arrow_paint = ft.Paint(color=ft.Colors.BLACK, stroke_width=2, style=ft.PaintingStyle.FILL)
        
        # X-axis arrow (right)
        x_arrow_x, x_arrow_y = to_screen(visible_x_max, 0, canvas_width, canvas_height)
        shapes.append(cv.Path(
            [
                cv.Path.MoveTo(x_arrow_x - arrow_size, x_arrow_y - arrow_size // 2),
                cv.Path.LineTo(x_arrow_x, x_arrow_y),
                cv.Path.LineTo(x_arrow_x - arrow_size, x_arrow_y + arrow_size // 2),
            ],
            arrow_paint
        ))
        
        # Y-axis arrow (top)
        y_arrow_x, y_arrow_y = to_screen(0, visible_y_max, canvas_width, canvas_height)
        shapes.append(cv.Path(
            [
                cv.Path.MoveTo(y_arrow_x - arrow_size // 2, y_arrow_y + arrow_size),
                cv.Path.LineTo(y_arrow_x, y_arrow_y),
                cv.Path.LineTo(y_arrow_x + arrow_size // 2, y_arrow_y + arrow_size),
            ],
            arrow_paint
        ))
        
        # Draw axis labels
        # X label
        shapes.append(cv.Text(
            x_arrow_x - arrow_size, x_arrow_y - 15, "x", 
            ft.TextStyle(size=12, weight=ft.FontWeight.BOLD)
        ))
        # Y label
        shapes.append(cv.Text(
            y_arrow_x + 5, y_arrow_y + arrow_size, "y",
            ft.TextStyle(size=12, weight=ft.FontWeight.BOLD)
        ))
        # 0 at origin
        shapes.append(cv.Text(
            cx - 10, cy + 10, "0",
            ft.TextStyle(size=10)
        ))
        
        # Draw tick marks and labels
        tick_paint = ft.Paint(color=ft.Colors.BLACK, stroke_width=1)
        
        # X-axis ticks
        for x in np.arange(-20, 21, 2):
            if x != 0:  # Skip 0 since we already labeled it
                sx, sy = to_screen(x, 0, canvas_width, canvas_height)
                if 0 <= sx <= canvas_width:
                    # Tick mark
                    shapes.append(cv.Line(sx, cy - 5, sx, cy + 5, tick_paint))
                    # Label
                    shapes.append(cv.Text(
                        sx - 5, cy + 10, str(int(x)),
                        ft.TextStyle(size=10)
                    ))
        
        # Y-axis ticks
        for y in np.arange(-20, 21, 2):
            if y != 0:  # Skip 0 since we already labeled it
                sx, sy = to_screen(0, y, canvas_width, canvas_height)
                if 0 <= sy <= canvas_height:
                    # Tick mark
                    shapes.append(cv.Line(cx - 5, sy, cx + 5, sy, tick_paint))
                    # Label
                    shapes.append(cv.Text(
                        cx - 20, sy + 5, str(int(y)),
                        ft.TextStyle(size=10)
                    ))
        
        # Draw algebraic curve
        try:
            curve_paint = ft.Paint(
                color=ft.Colors.RED, 
                stroke_width=3, 
                style=ft.PaintingStyle.STROKE
            )
            path_elements = []
            
            # Sample points across visible range
            x_vals = np.linspace(visible_x_min, visible_x_max, 400)
            
            # Safe evaluation of expression
            y_vals = []
            for x in x_vals:
                try:
                    y = eval(state["expr"], {"x": x, "np": np})
                    y_vals.append(y)
                except:
                    y_vals.append(float('nan'))
            
            # Create path
            first_valid = True
            for i in range(len(x_vals)):
                if not np.isnan(y_vals[i]):
                    sx, sy = to_screen(x_vals[i], y_vals[i], canvas_width, canvas_height)
                    if first_valid:
                        path_elements.append(cv.Path.MoveTo(sx, sy))
                        first_valid = False
                    else:
                        path_elements.append(cv.Path.LineTo(sx, sy))
            
            if path_elements:
                shapes.append(cv.Path(path_elements, curve_paint))
        except Exception as e:
            print(f"Graph drawing error: {e}")
        
        return shapes
    
    # Canvas reference for updating
    canvas_ref = ft.Ref[cv.Canvas]()
    
    def update_canvas():
        """Update the canvas with new shapes"""
        if canvas_ref.current:
            canvas_ref.current.shapes = draw_graph(page.width, page.height)
            canvas_ref.current.update()
    
    # Event handlers for pan and zoom
    def handle_pan_update(e: ft.DragUpdateEvent):
        """Handle pan (drag) updates - moves the visible coordinate system"""
        # Convert screen delta to mathematical coordinates
        # Dragging right by N pixels moves the view right, which means coordinates move left
        math_delta_x = -e.local_delta.x / state["scale"]
        math_delta_y = e.local_delta.y / state["scale"]  # Y is inverted in screen coords
        
        state["offset_x"] += e.local_delta.x
        state["offset_y"] += e.local_delta.y
        update_canvas()
    
    def handle_scroll(e: ft.ScrollEvent):
        """Handle scroll for zoom"""
        zoom_factor = 1.1 if e.scroll_delta_y < 0 else 0.9
        state["scale"] *= zoom_factor
        update_canvas()
    
    def handle_zoom_in(e):
        """Zoom in"""
        state["scale"] *= 1.2
        update_canvas()
    
    def handle_zoom_out(e):
        """Zoom out"""
        state["scale"] *= 0.8
        update_canvas()
    
    def handle_pan_up(e):
        """Pan up"""
        state["offset_y"] += 30
        update_canvas()
    
    def handle_pan_down(e):
        """Pan down"""
        state["offset_y"] -= 30
        update_canvas()
    
    def handle_pan_left(e):
        """Pan left"""
        state["offset_x"] -= 30
        update_canvas()
    
    def handle_pan_right(e):
        """Pan right"""
        state["offset_x"] += 30
        update_canvas()
    
    # Create the canvas
    chart_canvas = cv.Canvas(
        ref=canvas_ref,
        shapes=[],
        expand=True,
    )
    
    # Create transparent gesture detector overlay
    gesture_detector = ft.GestureDetector(
        mouse_cursor=ft.MouseCursor.MOVE,
        drag_interval=10,
        on_pan_update=handle_pan_update,
        on_scroll=handle_scroll,
    )
    
    # Stack canvas and gesture detector
    canvas_container = ft.Stack(
        expand=True,
        controls=[
            chart_canvas,
            gesture_detector,
        ],
    )
    
    # Create top bar
    async def handle_menu_click(e):
        await page.show_drawer()
    
    top_bar = ft.AppBar(
        title=ft.Text("Algebra Visualization", color=ft.Colors.WHITE),
        bgcolor=ft.Colors.BLUE,
        leading=ft.IconButton(icon=ft.Icons.MENU, on_click=handle_menu_click),
        actions=[
            ft.IconButton(icon=ft.Icons.GRAPHIC_EQ),
            ft.Dropdown(
                width=150,
                options=[
                    ft.dropdown.Option("Graphing"),
                    ft.dropdown.Option("Algebra"),
                    ft.dropdown.Option("Geometry"),
                ],
            ),
            ft.IconButton(icon=ft.Icons.SHARE),
            ft.TextButton(content=ft.Text("ASSIGN", color=ft.Colors.WHITE)),
            ft.TextButton(content=ft.Text("SIGN IN", color=ft.Colors.WHITE)),
        ],
    )
    
    # Create input field for expressions
    def handle_expr_change(e):
        state["expr"] = e.control.value
        update_canvas()
    
    input_field = ft.TextField(
        hint_text="Enter function (e.g., x**2, sin(x), etc.)",
        width=400,
        border=ft.InputBorder.NONE,
        filled=True,
        bgcolor=ft.Colors.GREY_100,
        on_change=handle_expr_change,
        value="x**2"
    )
    
    # Create zoom functions for floating action buttons
    def handle_zoom_in(e):
        """Zoom in"""
        state["scale"] *= 1.2
        update_canvas()
    
    def handle_zoom_out(e):
        """Zoom out"""
        state["scale"] *= 0.8
        update_canvas()
    
    def handle_reset_view(e):
        """Reset view to default"""
        state["scale"] = 50.0
        state["offset_x"] = 0.0
        state["offset_y"] = 0.0
        update_canvas()
    
    # Create control buttons for panning
    btn_pan_up = ft.IconButton(
        icon=ft.Icons.ARROW_UPWARD,
        on_click=handle_pan_up,
        tooltip="Pan Up",
    )
    
    btn_pan_down = ft.IconButton(
        icon=ft.Icons.ARROW_DOWNWARD,
        on_click=handle_pan_down,
        tooltip="Pan Down",
    )
    
    btn_pan_left = ft.IconButton(
        icon=ft.Icons.ARROW_BACK,
        on_click=handle_pan_left,
        tooltip="Pan Left",
    )
    
    btn_pan_right = ft.IconButton(
        icon=ft.Icons.ARROW_FORWARD,
        on_click=handle_pan_right,
        tooltip="Pan Right",
    )
    
    # Create floating action buttons
    fab_zoom_in = ft.FloatingActionButton(
        icon=ft.Icons.ADD,
        on_click=handle_zoom_in,
        bgcolor=ft.Colors.BLUE,
        foreground_color=ft.Colors.WHITE,
        tooltip="Zoom In",
    )
    
    fab_zoom_out = ft.FloatingActionButton(
        icon=ft.Icons.REMOVE,
        on_click=handle_zoom_out,
        bgcolor=ft.Colors.BLUE,
        foreground_color=ft.Colors.WHITE,
        tooltip="Zoom Out",
    )
    
    fab_reset = ft.FloatingActionButton(
        icon=ft.Icons.REFRESH,
        on_click=handle_reset_view,
        bgcolor=ft.Colors.BLUE,
        foreground_color=ft.Colors.WHITE,
        tooltip="Reset View",
    )
    
    # Main content layout
    coordinate_content = ft.Container(
        content=canvas_container,
        expand=True,
        padding=20,
        border=ft.Border.all(1, ft.Colors.GREY_300),
    )
    
    # Stack to hold coordinate system and controls
    content_with_controls = ft.Stack(
        expand=True,
        controls=[
            coordinate_content,
            # Input field at top
            ft.Container(
                content=input_field,
                top=10,
                left=20,
            ),
            # Pan Up button - top center
            ft.Container(
                content=btn_pan_up,
                top=20,
                left=page.width // 2 - 20,
            ),
            # Pan Left button - middle left
            ft.Container(
                content=btn_pan_left,
                top=page.height // 2 - 70,
                left=20,
            ),
            # Pan Right button - middle right
            ft.Container(
                content=btn_pan_right,
                top=page.height // 2 - 70,
                right=20,
            ),
            # Pan Down button - bottom center
            ft.Container(
                content=btn_pan_down,
                bottom=110,
                left=page.width // 2 - 20,
            ),
            # Zoom In button - bottom right
            ft.Container(
                content=fab_zoom_in,
                right=20,
                bottom=20,
            ),
            # Zoom Out button - bottom left
            ft.Container(
                content=fab_zoom_out,
                left=20,
                bottom=20,
            ),
            # Reset button - middle bottom
            ft.Container(
                content=fab_reset,
                bottom=20,
                left=page.width // 2 - 30,
            ),
        ],
    )
    
    # Main content
    main_content = ft.Column(
        controls=[
            top_bar,
            content_with_controls,
        ],
        expand=True,
    )
    
    # Set the drawer on the page
    page.drawer = navigation_drawer
    
    # Add the main content to the page
    page.add(main_content)
    
    # Initial canvas draw
    page.update()
    update_canvas()

if __name__ == "__main__":
    ft.run(main)