import flet as ft

def main(page: ft.Page):
    # Set page properties
    page.title = "GeoGebra Calculator Suite"
    page.vertical_alignment = ft.MainAxisAlignment.CENTER
    page.horizontal_alignment = ft.CrossAxisAlignment.CENTER
    page.padding = 0
    page.window_width = 1200
    page.window_height = 800
    page.bgcolor = ft.Colors.WHITE
    
    # Create navigation drawer with menu items
    drawer_items = [
        ft.Container(height=12),
        ft.NavigationDrawerDestination(
            label="Algebra",
            icon=ft.Icons.ADD_OUTLINED,
            selected_icon=ft.Icons.ADD,
        ),
        ft.NavigationDrawerDestination(
            label="Tools",
            icon=ft.Icons.SETTINGS_OUTLINED,
            selected_icon=ft.Icons.SETTINGS,
        ),
        ft.NavigationDrawerDestination(
            label="Table",
            icon=ft.Icons.TABLE_CHART_OUTLINED,
            selected_icon=ft.Icons.TABLE_CHART,
        ),
        ft.NavigationDrawerDestination(
            label="Spreadsheet",
            icon=ft.Icons.GRID_ON_OUTLINED,
            selected_icon=ft.Icons.GRID_ON,
        ),
    ]
    
    def handle_drawer_dismiss(e: ft.Event[ft.NavigationDrawer]) -> None:
        """Handle drawer dismissal event."""
        print("Drawer dismissed!")
    
    async def handle_drawer_change(e: ft.Event[ft.NavigationDrawer]) -> None:
        """Handle drawer selection change event."""
        print(f"Selected Index changed: {e.control.selected_index}")
        await page.close_drawer()
    
    navigation_drawer = ft.NavigationDrawer(
        controls=drawer_items,
        on_dismiss=handle_drawer_dismiss,
        on_change=handle_drawer_change,
    )
    
    # Import required libraries for coordinate system
    import matplotlib.pyplot as plt
    import numpy as np
    import flet_charts as fch
    
    # Define initial axis limits for the coordinate system
    xlim_min: float = -10.0
    xlim_max: float = 10.0
    ylim_min: float = -10.0
    ylim_max: float = 10.0
    
    # Create matplotlib figure and axis for plotting
    fig, ax = plt.subplots(figsize=(8, 6))
    
    # Position spines (axes) at the origin (0,0) instead of center
    ax.spines['left'].set_position('zero')
    ax.spines['bottom'].set_position('zero')
    
    # Hide top and right spines for cleaner look
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    
    # Set initial axis limits
    ax.set_xlim(xlim_min, xlim_max)
    ax.set_ylim(ylim_min, ylim_max)
    
    # Set tick positions and labels
    ax.set_xticks(np.arange(-10, 11, 2))
    ax.set_yticks(np.arange(-10, 11, 2))
    
    # Set minor ticks for grid lines
    ax.set_xticks(np.arange(-10, 11, 1), minor=True)
    ax.set_yticks(np.arange(-10, 11, 1), minor=True)
    
    # Position ticks on bottom and left axes only
    ax.xaxis.set_ticks_position('bottom')
    ax.yaxis.set_ticks_position('left')
    
    # Hide '0' from tick labels (will be added separately at origin)
    new_xticks_labels = [label.get_text().replace('−', '-') if label.get_text().replace('−', '-') != '0' else ''
                          for label in ax.get_xticklabels()]
    ax.set_xticklabels(new_xticks_labels)
    
    new_yticks_labels = [label.get_text().replace('−', '-') if label.get_text().replace('−', '-') != '0' else ''
                          for label in ax.get_yticklabels()]
    ax.set_yticklabels(new_yticks_labels)
    
    # Add '0' annotation at the origin
    zero_annotation = ax.annotate('0', xy=(0, 0), xytext=(-5, -10), textcoords='offset points', ha='right', va='top')
    
    # Add major and minor grid lines for better visualization
    ax.grid(True, color='gray', linestyle='--', linewidth=0.5, which='major')
    ax.grid(True, color='lightgray', linestyle=':', linewidth=0.3, which='minor')
    
    # Create coordinate chart using Matplotlib
    coordinate_chart = fch.MatplotlibChart(
        figure=fig,
        expand=True,
    )
    
    coordinate_container = ft.Container(
        content=coordinate_chart,
        width=page.width,
        height=page.height,
        bgcolor=ft.Colors.WHITE,
        border=ft.Border.all(1, ft.Colors.GREY_300),
    )
    
    # Event handler for starting panning (dragging) the coordinate system
    def handle_pan_start(e: ft.DragStartEvent[ft.GestureDetector]) -> None:
        """Handle pan start event - change mouse cursor to move cursor."""
        e.control.mouse_cursor = ft.MouseCursor.MOVE
    
    # Event handler for ending panning (dragging) the coordinate system
    def handle_pan_end(e: ft.DragEndEvent[ft.GestureDetector]) -> None:
        """Handle pan end event - change mouse cursor back to default."""
        e.control.mouse_cursor = ft.MouseCursor.BASIC
    
    # Event handler for tertiary (middle mouse button) long press
    def handle_tertiary_long_press(e: ft.TapEvent[ft.GestureDetector]) -> None:
        """Handle tertiary (middle mouse button) long press event.
        
        This event is triggered when the middle mouse button is pressed and held.
        It's commonly used for:
        - Opening context menus
        - Special navigation actions
        - Custom gestures
        """
        print(f"Tertiary long press detected at position: ({e.local_x}, {e.local_y})")
        print("This is typically triggered by the middle mouse button or scroll wheel click")
    
    # Event handler for panning (dragging) the coordinate system
    def handle_pan_update(e: ft.DragUpdateEvent[ft.GestureDetector]) -> None:
        """Handle pan (drag) updates on the coordinate system.
        
        When user drags the mouse:
        - Dragging right moves the view right (coordinates move left)
        - Dragging left moves the view left (coordinates move right)
        - Dragging down moves the view down (coordinates move up)
        - Dragging up moves the view up (coordinates move down)
        """
        nonlocal xlim_min, xlim_max, ylim_min, ylim_max
        
        # Get drag deltas (movement in pixels)
        dx: float = e.local_delta.x
        dy: float = e.local_delta.y
        
        # Calculate data coordinate shifts based on canvas size and current range
        data_range_x: float = xlim_max - xlim_min
        data_range_y: float = ylim_max - ylim_min
        
        # Convert pixel movement to data coordinates
        # Canvas is 800x600. Positive dx right means move the view right (shift limits left)
        shift_x: float = -(dx / page.width) * data_range_x
        shift_y: float = (dy / page.height) * data_range_y  # Y is inverted
        
        # Update axis limits
        xlim_min += shift_x
        xlim_max += shift_x
        ylim_min += shift_y
        ylim_max += shift_y
        
        # Set new axis limits
        ax.set_xlim(xlim_min, xlim_max)
        ax.set_ylim(ylim_min, ylim_max)
        
        # Update tick positions and labels
        tick_step: int = 2
        
        # Calculate new tick positions
        x_tick_min: float = np.floor(xlim_min / tick_step) * tick_step
        x_tick_max: float = np.ceil(xlim_max / tick_step) * tick_step
        new_xticks: np.ndarray = np.arange(x_tick_min, x_tick_max + tick_step, tick_step)
        
        y_tick_min: float = np.floor(ylim_min / tick_step) * tick_step
        y_tick_max: float = np.ceil(ylim_max / tick_step) * tick_step
        new_yticks: np.ndarray = np.arange(y_tick_min, y_tick_max + tick_step, tick_step)
        
        ax.set_xticks(new_xticks)
        ax.set_yticks(new_yticks)
        
        # Update minor ticks for grid lines
        minor_tick_step: int = 1
        x_minor_tick_min: float = np.floor(xlim_min / minor_tick_step) * minor_tick_step
        x_minor_tick_max: float = np.ceil(xlim_max / minor_tick_step) * minor_tick_step
        new_x_minor_ticks: np.ndarray = np.arange(x_minor_tick_min, x_minor_tick_max + minor_tick_step, minor_tick_step)
        
        y_minor_tick_min: float = np.floor(ylim_min / minor_tick_step) * minor_tick_step
        y_minor_tick_max: float = np.ceil(ylim_max / minor_tick_step) * minor_tick_step
        new_y_minor_ticks: np.ndarray = np.arange(y_minor_tick_min, y_minor_tick_max + minor_tick_step, minor_tick_step)
        
        ax.set_xticks(new_x_minor_ticks, minor=True)
        ax.set_yticks(new_y_minor_ticks, minor=True)
        
        # Format tick labels - hide 0 from ticks, we'll add it separately
        x_labels: list[str] = [f'{int(x)}' if x != 0 else '' for x in new_xticks]
        y_labels: list[str] = [f'{int(y)}' if y != 0 else '' for y in new_yticks]
        
        ax.set_xticklabels(x_labels)
        ax.set_yticklabels(y_labels)
        
        # Update '0' annotation at origin
        zero_annotation.set_position((0, 0))
        
        # Force complete redraw
        fig.canvas.draw_idle()
        coordinate_chart.update()
    
    # Create transparent container for gesture detection
    transparent_container = ft.Container(
        width=page.width,
        height=page.height,
        bgcolor=ft.Colors.TRANSPARENT,
    )
    
    # Wrap transparent container in GestureDetector for dragging
    # drag_interval controls how often drag events are fired (in milliseconds)
    # Lower values = smoother dragging but higher CPU usage
    gesture_detector = ft.GestureDetector(
        content=transparent_container,
        mouse_cursor=ft.MouseCursor.BASIC,
        drag_interval=5,  # Changed from 10 to 5 for smoother dragging
        on_pan_start=handle_pan_start,
        on_pan_end=handle_pan_end,
        on_pan_update=handle_pan_update,
        on_tertiary_long_press=handle_tertiary_long_press,  # Test middle mouse button long press
    )
    
    # Stack coordinate chart and transparent gesture detector
    stack = ft.Stack(
        width=page.width,
        height=page.height,
        controls=[
            coordinate_container,
            gesture_detector,
        ],
    )
    
    # Wrap in InteractiveViewer for zoom and pan
    coordinate_system = ft.InteractiveViewer(
        content=stack,
        min_scale=0.5,
        max_scale=5.0,
        boundary_margin=ft.Margin.all(100),
    )
    
    # Create top bar with menu and actions
    async def handle_menu_click(e) -> None:
        """Handle menu button click to show navigation drawer."""
        await page.show_drawer()
    
    top_bar = ft.AppBar(
        title=ft.Text("Algebra Visualization", color=ft.Colors.WHITE),
        bgcolor=ft.Colors.BLUE,
        leading=ft.IconButton(icon=ft.Icons.MENU, on_click=handle_menu_click),
        actions=[
            ft.IconButton(icon=ft.Icons.GRAPHIC_EQ),
            ft.Dropdown(
                width=150,
                options=[
                    ft.dropdown.Option("Graphing"),
                    ft.dropdown.Option("Algebra"),
                    ft.dropdown.Option("Geometry"),
                ],
            ),
            ft.IconButton(icon=ft.Icons.SHARE),
            ft.TextButton(content=ft.Text("ASSIGN", color=ft.Colors.WHITE)),
            ft.TextButton(content=ft.Text("SIGN IN", color=ft.Colors.WHITE)),
        ],
    )
    
    # Create input field for user input
    input_field = ft.TextField(
        hint_text="Input...",
        width=300,
        border=ft.InputBorder.NONE,
    )
    
    # Main content layout
    main_content = ft.Column(
        controls=[
            top_bar,
            ft.Container(
                expand=True,
                content=coordinate_system,
                padding=20,
            ),
        ],
        expand=True,
    )
    
    # Set the drawer on the page
    page.drawer = navigation_drawer
    
    # Add the main content to the page
    page.add(main_content)

if __name__ == "__main__":
    ft.run(main)